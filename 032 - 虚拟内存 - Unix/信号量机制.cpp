Семафор - 信号量机制

用户进程可以使用OS提供的一对原语来对信号量进行操作
一对原语：wait signal（P、V о操作）

整型信号量
    - 用一个整型变量来表示系统中某种资源数量
    - 与普通变量的区别：对信号量的操作只有3种：初始化、P、V
    - 存在的问题：不满足“让权等待”原则，会发生忙等


// 初始化整型信号量S，表示当前系统中可用的资源数
int S = 1;

// “检查”和“上锁”一气呵成，避免了并发、异步导致的问题
void wait(int S)        // “wait”原语，相当于进去等待区
{
    while (S <= 0);     // 如果资源数不够，就一直循环等待
    S = S - 1;          // 如果资源数够，就分配一个资源
}

void signal(int S)      // “signal”原语，相当于“退出区”
{
    S = S + 1;          // 使用完资源后，在退出区释放资源
}

进程P0：
    。。。
    wait(S);            // 进入区，申请资源
    Использование ресурсов // 临界区，访问资源 
    signal(S);          //  退出区，释放资源
    。。。


===========================================================================
记录型信号量 - 用记录型数据结构表示的信号量
该机制遵循了让权等待原则，不会出现忙等


// 定义
typedef struct
{
    int value;          // 剩余的资源数
    struct process* L;  // 等待队列
}

void wait(semaphore S)
{
    S.value--;
    if (S.value < 0)
    {
        block(S.L)      // 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，将进程加入等待队列
    }
}

void signal(semaphore S)
{
    S.value++;
    if (S.value <= 0)
    {
        wakeup(S.L)     //释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，使该进程从阻塞态变为就绪态
    }
}