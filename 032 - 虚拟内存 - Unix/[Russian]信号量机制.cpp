Семафор - 信号量机制

Пользователь работает на семафоре через пару 【примитивов】, предоставляемых операционной системой
一对原语：wait signal（P、V операция）

Целостный семафор
    - Целая переменная используется в качестве семафора для представления количества некоторого ресурса в системе
    - Есть только две операции над семафорами, инициализация, P, V.
    - Проблема: "принцип ожидания" не соблюдается, и происходит "занятое ожидание"


// Инициализировать семафор S, указав количество ресурсов, имеющихся в настоящее время в системе
int S = 1;

// "Проверка" и "блокировка" выполняются за один раз, избегая проблем, вызванных параллельностью и асинхронией
void wait(int S)        // Оригинальное слово "wait" эквивалентно в【ходить в зону ожидания】.
{
    while (S <= 0);     // Если не хватает ресурсов, продолжайте ждать
    S = S - 1;          // Если ресурсов достаточно, возьмитесь за ресурс
}

void signal(int S)      // Эквивалент "зоны выхода"
{
    S = S + 1;          // Освободите ресурсы в зоне выхода, когда закончите использовать их
}

进程P0：
    。。。
    wait(S);            // Войти в зону и запросить ресурсы
    Использование ресурсов // Критические области, доступ к ресурсам 
    signal(S);          // Эквивалент "зоны выхода"，освобождение ресурса
    。。。


===========================================================================
Записанный семафор - семафор, представленный структурой данных типа записи.
Этот механизм следует принципу let-right-wait и не будет занят и т.д.


// 定义
typedef struct
{
    int value;          // Количество оставшихся ресурсов
    struct process* L;  // Очередь ожидания
}

void wait(semaphore S)
{
    S.value--;
    if (S.value < 0)
    {
        block(S.L)      // Если ресурсов не хватает, используйте оператор "блок", 
                        // чтобы вывести процесс из работающего состояния в состояние блокировки. И добавить процесс в очередь ожидания
    }
}

void signal(semaphore S)
{
    S.value++;
    if (S.value <= 0)
    {
        wakeup(S.L)     // После освобождения ресурса, если есть другие процессы, ожидающие его, используйте оператор "wakeup", 
                        // чтобы разбудить один процесс из очереди ожидания.
                        // И это процесс переходит из состояния блокировки в состояние готовности
    }
}